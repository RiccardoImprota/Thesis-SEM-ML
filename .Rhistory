setwd("~/GitHub/Thesis-SEM-ML")
# Tidyverse
library(dplyr)
library(purrr)
library(readr)
library(ggplot2)
library(tidyr)
# Additional libraries used for this analysis
library(sjlabelled)  # Labeling data
library(psych)  # Psychometric analysis and data manipulation
# Load custom functions from external script
source("functions.R")
# Specify the country of interest: Italy (16)
countries <- c(16)
# Define the variables of interest
variablestopredict <- c("eng_energy", "eng_enthusiastic", "eng_timeflies")
# Determine whether to include M1 questions in the analysis (more NAs, but more variables)
consideringM1<-TRUE
# Import the original dataset using a custom function
sourcedf <- ImportOriginalDataset()
# Tidyverse
library(dplyr)
library(purrr)
library(readr)
library(ggplot2)
library(tidyr)
# Additional libraries used for this analysis
library(sjlabelled)  # Labeling data
library(psych)  # Psychometric analysis and data manipulation
# Load custom functions from external script
source("functions.R")
# Specify the country of interest: Italy (16)
countries <- c(16)
# Define the variables of interest
variablestopredict <- c("eng_energy", "eng_enthusiastic", "eng_timeflies")
# Determine whether to include M1 questions in the analysis (more NAs, but more variables)
consideringM1<-TRUE
# Import the original dataset using a custom function
sourcedf <- ImportOriginalDataset()
# Check the levels and labels of the 'private_sector' variable to see if the data is sound
levels(sourcedf$private_sector)
names(attributes(sourcedf$private_sector)$labels)
# If consideringM1 is FALSE, exclude M1 from selected variables
usedvar <- ImportUsedvar(M1 = consideringM1)
# Select the necessary variables from the dataset, filter for employees, and remove the 'employee_selfdeclared' variable
df <- sourcedf %>%
select(all_of(usedvar$variable)) %>%
filter(employee_selfdeclared == 1) %>%
select(-employee_selfdeclared)
# Update the list of used variables, removing 'employee_selfdeclared' after filtering
usedvar <- usedvar %>% filter(variable != "employee_selfdeclared")
# Check summaries for 'seniority' and 'predict_earnings' variables
summary(df$seniority)
summary(df$predict_earnings)
# Check summaries for work engagement
summary(df$eng_energy)
# Define the values that need to be replaced with NA
values_to_na <- c(-777, -888,-998, -999)
# Replace these values with NA in the dataset, and drop unused levels in factor variables
df <- df %>%
mutate(across(everything(), ~replace(., . %in% values_to_na, NA)))
#%>%  mutate(across(where(is.factor), ~droplevels(.)))
# Check summaries again for 'seniority' and 'predict_earnings' variables
summary(df$seniority)
summary(df$predict_earnings)
# Check summaries for work engagement
summary(df$eng_timeflies)
summary(df$eng_energy)
summary(df$eng_enthusiastic)
# Filter for the specified country (Italy) and ensure all outcome variables have non-NA values
df <- df %>%
filter(Country %in% countries) %>%
filter(across(all_of(variablestopredict), any_vars(!is.na(.))))
# Check summaries again for 'seniority' and 'predict_earnings' variables to compare with previous scripts
summary(df$seniority)
summary(df$predict_earnings)
# Visualize potential outliers with a boxplot
boxplot(df$age, df$seniority, df$usual_hours_week, names = c("age", "seniority", "usual_hours_week"),
main = "Boxplot of Variables",
xlab = "Variable",
ylab = "Value",
col = "lightblue")
# Define a function to remove extreme outliers (those that fall outside a specified number of standard deviations from the mean)
remove_extreme_outliers <- function(df, threshold = 4) {
# Store original number of rows
original_nrow <- nrow(df)
# Iterate over all numeric columns
df <- df %>%
mutate(across(where(is.numeric),
list(outlier = ~ifelse(is.na(.), NA, abs((. - mean(., na.rm = TRUE)) / sd(., na.rm = TRUE)) <= threshold)),
.names = "{.col}_outlier")) %>%
filter(if_all(ends_with("_outlier"), ~is.na(.) | .)) %>%
select(-ends_with("_outlier"))
# Calculate and print number of rows removed
removed_rows <- original_nrow - nrow(df)
print(paste("Removed", removed_rows, "rows"))
return(df)
}
df <- remove_extreme_outliers(df)
# Get the count of NA values for each column in your dataframe
na_count <- df %>% summarise_all(function(x) sum(is.na(x)))
na_count <- na_count %>% pivot_longer(cols = everything(), names_to = "variable", values_to = "value")
# Create histogram
ggplot(na_count, aes(x = value, y = reorder(variable, value))) +
geom_bar(stat = "identity", width = 0.5, fill = "steelblue") +
labs(x = "Count of NA", y = "Variable") +
xlim(0, nrow(df)) +
theme(axis.text.y = element_text(angle = 0, hjust = 1))
df_numeric <- df %>%
mutate_all(~ as.numeric(as.character(.)))
# just saving the datasets in different formats
write_spss(df, "../../data/processed/df_numeric.sav")
write_csv(df_numeric, "../../data/processed/df_numeric.csv")
# This code is functionally useless for the reader, but it was made to setup a .csv
# where I could manually label the variables that needed to be reversed.
# I used Cronbach Alpha scores to help me through the process.
var_info <- tibble(variables = character(),
labels = character(),
Values = character())
# Loop through each variable
for (var in names(df)) {
levels <- as.character(levels(df[[var]]))
names <- names(attributes(df[[var]])$labels)
combined <- paste(levels, names, sep = ": ")
output <- paste0("{", paste(combined, collapse = ", "), "}")
var_info <- var_info %>%
add_row(variables = var,
labels = attr(df[[var]], "label"),
Values = output)
}
#write_csv(var_info, "../data/processed/var_info.csv")
# Tidyverse
library(dplyr)  # Data manipulation
library(purrr)  # Functional programming
library(readr)  # Data import
# Additional libraries used for this analysis
library(sjlabelled)  # Labeling data
library(psych)  # Psychometric analysis and data manipulation
source("functions.R")
library(corrplot)
df <- read_csv("../../data/processed/df_numeric.csv", show_col_types = FALSE)
reversedf<-read_csv2("../../data/var_to_reverse.csv", show_col_types = FALSE)
# Using the syntax of the prepared .csv, we can setup an array of variables to reverse
vars_to_reverse <- as.character(na.omit(reversedf[reversedf$toreverse == 'y', ])$variables)
# Define a function to reverse the scale of a numeric variable.
reverse_variable <- function(x) {
max_val = max(x, na.rm = TRUE)
min_val = min(x, na.rm = TRUE)
return(max_val - x + min_val)
}
print(head(df$noise,15))
# Apply the reverse_variable function to specified columns in the dataframe.
df <- df %>%
mutate(across(all_of(vars_to_reverse), reverse_variable))
# Print the first 15 values of 'noise' column after the reversal for verification
print(head(df$noise,15))
usedvar <- ImportUsedvar(M1=TRUE) %>% filter(variable != "employee_selfdeclared")
dimensionsdf<- usedvar %>% filter(!is.na(dimension)) %>% select(variable, dimension)
#Saving the new dataframe where the correct variables are reversed
write_csv(df, "../../data/processed//df_reversed.csv")
# Get the names of the columns where max value is either 2 or above 6
variables_to_remove <- names(df)[sapply(df, function(x) max(x, na.rm = TRUE) %in% 2 | max(x, na.rm = TRUE) > 6)]
# Keep only variables_to_remove_for_alpha that are present in the "variable" column of dimensionsdf
variables_to_remove <- variables_to_remove[variables_to_remove %in% dimensionsdf$variable]
# Remove those columns from df
df <- df %>% select(-variables_to_remove)
dimensionsdf <- dimensionsdf %>% filter(!variable %in% all_of(variables_to_remove))
dimensionsdf$dimension %>%
unique() %>%
purrr::map_df(~list( dimension = .x,
alpha = psych::alpha(df[, dimensionsdf$variable[dimensionsdf$dimension == .x]],check.keys = TRUE)$total[["std.alpha"]]
))
### Complete alpha output for all dimensions
for (dim in unique(dimensionsdf$dimension)) {
message <- paste("Dimension being considered:", dim)
border <- strrep("*", nchar(message) + 4)
cat(paste0("\n", border, "\n* ", message, " *\n", border, "\n"), sep = "")
# Get the variables for the desired dimension
dim_variables <- dimensionsdf$variable[dimensionsdf$dimension == dim]
# Remove the excluded variables
exclude_var <- c()
dim_variables <- dim_variables[!dim_variables %in% exclude_var]
# Compute the alpha coefficient
print(psych::alpha(df[, dim_variables]))
# Create the correlation matrix
df_corr <- df[, dim_variables]
corr_matrix <- cor(df_corr, use="pairwise.complete.obs")
# Add extra margin at the top
par(mar = c(4, 4, 2, 2) + 0.1)
# Create the correlation plot
corrplot(corr_matrix, method = "color", order = "hclust",
addCoef.col = "black", # Add correlation coefficient to the plot
tl.col = "black", tl.srt = 45, # Text color and rotation
title=dim, # Set the title
mar=c(0,0,1,0) # http://stackoverflow.com/a/14754408/54964
)
}
